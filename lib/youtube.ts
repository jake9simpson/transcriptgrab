import type { TranscriptSegment, CaptionTrack, TranscriptResult } from './types';

const VIDEO_ID_REGEX = /^[a-zA-Z0-9_-]{11}$/;
const ANDROID_USER_AGENT = 'com.google.android.youtube/19.09.37 (Linux; Android 13)';
const INNERTUBE_API_KEY = 'AIzaSyAO_FJ2SlqU8Q4STEHLGCilw_Y9_11qcW8';

/**
 * Extract a YouTube video ID from a URL or bare ID string.
 */
export function extractVideoId(url: string): string | null {
  const trimmed = url.trim();

  if (VIDEO_ID_REGEX.test(trimmed)) {
    return trimmed;
  }

  let parsed: URL;
  try {
    parsed = new URL(trimmed);
  } catch {
    return null;
  }

  const hostname = parsed.hostname.replace(/^www\./, '');

  if (hostname === 'youtu.be') {
    const id = parsed.pathname.slice(1).split('/')[0];
    return VIDEO_ID_REGEX.test(id) ? id : null;
  }

  if (hostname !== 'youtube.com' && hostname !== 'm.youtube.com') {
    return null;
  }

  if (parsed.pathname === '/watch') {
    const id = parsed.searchParams.get('v');
    return id && VIDEO_ID_REGEX.test(id) ? id : null;
  }

  const pathMatch = parsed.pathname.match(/^\/(shorts|live|embed)\/([a-zA-Z0-9_-]{11})/);
  if (pathMatch) {
    return pathMatch[2];
  }

  return null;
}

/**
 * Call YouTube's InnerTube player API with ANDROID client context.
 * This works from cloud IPs where browser-based scraping fails.
 */
async function innertubePlayer(videoId: string, lang?: string): Promise<{
  tracks: CaptionTrack[];
  rawTracks: Array<{ languageCode: string; baseUrl: string; name: { simpleText?: string } | string; kind?: string }>;
  lengthSeconds: number | null;
}> {
  const res = await fetch(
    `https://www.youtube.com/youtubei/v1/player?key=${INNERTUBE_API_KEY}`,
    {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'User-Agent': ANDROID_USER_AGENT,
      },
      body: JSON.stringify({
        context: {
          client: {
            clientName: 'ANDROID',
            clientVersion: '19.09.37',
            androidSdkVersion: 33,
            hl: lang ?? 'en',
            gl: 'US',
          },
        },
        videoId,
      }),
    }
  );

  if (!res.ok) {
    throw new Error(`InnerTube player API returned HTTP ${res.status}`);
  }

  const data = await res.json();

  // Check playability
  const status = data?.playabilityStatus?.status;
  if (status === 'ERROR' || status === 'UNPLAYABLE') {
    throw new Error(`This video is private or unavailable.`);
  }

  const captionRenderer = data?.captions?.playerCaptionsTracklistRenderer;
  if (!captionRenderer?.captionTracks?.length) {
    throw new Error(`This video doesn't have captions/subtitles available.`);
  }

  const rawTracks = captionRenderer.captionTracks;

  const lengthSeconds = data?.videoDetails?.lengthSeconds
    ? parseInt(data.videoDetails.lengthSeconds, 10)
    : null;

  const tracks: CaptionTrack[] = rawTracks.map((t: { languageCode: string; baseUrl: string; name: { simpleText?: string } | string; kind?: string }) => ({
    languageCode: t.languageCode ?? 'unknown',
    name: typeof t.name === 'string' ? t.name : t.name?.simpleText ?? 'Unknown',
    baseUrl: t.baseUrl ?? '',
    isAutoGenerated: t.kind === 'asr',
  }));

  return { tracks, rawTracks, lengthSeconds };
}

/**
 * Fetch and parse timedtext XML from a caption track URL.
 */
async function fetchTimedText(baseUrl: string): Promise<TranscriptSegment[]> {
  const res = await fetch(baseUrl, {
    headers: { 'User-Agent': ANDROID_USER_AGENT },
  });

  if (!res.ok) {
    throw new Error(`Timedtext fetch failed: HTTP ${res.status}`);
  }

  const xml = await res.text();

  if (!xml || xml.length === 0) {
    throw new Error('Timedtext response was empty');
  }

  const segments: TranscriptSegment[] = [];

  // Try standard timedtext format first: <text start="..." dur="...">...</text>
  const standardRegex = /<text start="([^"]*)" dur="([^"]*)"[^>]*>([\s\S]*?)<\/text>/g;
  let match: RegExpExecArray | null;

  while ((match = standardRegex.exec(xml)) !== null) {
    const text = match[3].replace(/<[^>]*>/g, '').trim();
    if (text) {
      segments.push({
        start: parseFloat(match[1]),
        duration: parseFloat(match[2]),
        text,
      });
    }
  }

  if (segments.length > 0) return segments;

  // Try ASR format: <p t="..." d="..."><s>...</s></p>
  const asrRegex = /<p t="(\d+)" d="(\d+)"[^>]*>([\s\S]*?)<\/p>/g;
  const segmentPartRegex = /<s[^>]*>([^<]*)<\/s>/g;

  while ((match = asrRegex.exec(xml)) !== null) {
    const parts = [...match[3].matchAll(segmentPartRegex)];
    const text = parts.length > 0
      ? parts.map((s) => s[1]).join('').trim()
      : match[3].replace(/<[^>]*>/g, '').trim();

    if (text) {
      segments.push({
        start: Number(match[1]) / 1000,
        duration: Number(match[2]) / 1000,
        text,
      });
    }
  }

  return segments;
}

/**
 * Randomly pick a Supadata API key to distribute usage evenly across keys.
 */
function getSupadataKey(): string {
  const keys = [process.env.SUPADATA_API_KEY, process.env.SUPADATA_API_KEY_2, process.env.SUPADATA_API_KEY_3].filter(Boolean) as string[];
  if (keys.length === 0) {
    throw new Error('SUPADATA_API_KEY is not configured');
  }
  return keys[Math.floor(Math.random() * keys.length)];
}

/**
 * Fetch transcript via Supadata API (fallback when InnerTube fails).
 */
async function fetchViaSupadata(
  videoId: string,
  languageCode?: string
): Promise<TranscriptResult> {
  const apiKey = getSupadataKey();

  const lang = languageCode ?? 'en';
  const url = `https://api.supadata.ai/v1/transcript?url=https://youtu.be/${videoId}&lang=${lang}`;

  const res = await fetch(url, {
    headers: { 'x-api-key': apiKey },
  });

  if (!res.ok) {
    throw new Error(`Supadata API returned HTTP ${res.status}`);
  }

  const data = await res.json() as {
    lang: string;
    content: Array<{ text: string; offset: number; duration: number; lang: string }>;
  };

  if (!data.content || data.content.length === 0) {
    throw new Error('Supadata returned no transcript content');
  }

  const segments: TranscriptSegment[] = data.content.map((item) => ({
    text: item.text,
    start: item.offset / 1000,
    duration: item.duration / 1000,
  }));

  const availableTracks: CaptionTrack[] = [
    {
      languageCode: data.lang ?? lang,
      name: data.lang ?? lang,
      baseUrl: '',
      isAutoGenerated: false,
    },
  ];

  return { segments, availableTracks, videoId, videoDuration: null };
}

/**
 * Fetch transcript for a YouTube video.
 * Tries InnerTube ANDROID client first, falls back to Supadata API.
 */
export async function fetchTranscript(
  videoId: string,
  languageCode?: string
): Promise<TranscriptResult> {
  let innertubeError: Error | undefined;

  try {
    const { tracks, rawTracks, lengthSeconds } = await innertubePlayer(videoId, languageCode);

    // Pick the right track
    let selectedTrack;
    if (languageCode) {
      selectedTrack = rawTracks.find((t) => t.languageCode === languageCode)
        ?? rawTracks.find((t) => t.languageCode.startsWith(languageCode + '-'))
        ?? rawTracks[0];
    } else {
      // Prefer non-auto-generated track
      selectedTrack = rawTracks.find((t) => t.kind !== 'asr') ?? rawTracks[0];
    }

    const segments = await fetchTimedText(selectedTrack.baseUrl);

    if (segments.length === 0) {
      throw new Error(`This video doesn't have captions/subtitles available.`);
    }

    console.log(`[transcriptgrab] InnerTube succeeded for ${videoId}`);
    return {
      segments,
      availableTracks: tracks,
      videoId,
      videoDuration: lengthSeconds,
    };
  } catch (err) {
    innertubeError = err instanceof Error ? err : new Error(String(err));
    console.log(`[transcriptgrab] InnerTube failed for ${videoId}: ${innertubeError.message}`);
  }

  // Fallback: Supadata API
  if (process.env.SUPADATA_API_KEY) {
    try {
      const result = await fetchViaSupadata(videoId, languageCode);
      console.log(`[transcriptgrab] Supadata fallback succeeded for ${videoId}`);
      return result;
    } catch (supadataErr) {
      console.log(
        `[transcriptgrab] Supadata fallback also failed for ${videoId}: ${supadataErr instanceof Error ? supadataErr.message : supadataErr}`
      );
    }
  }

  // Both methods failed â€” throw the original InnerTube error (more descriptive)
  throw innertubeError!;
}

/**
 * Fetch available caption tracks for a video.
 */
export async function fetchAvailableTracks(videoId: string): Promise<CaptionTrack[]> {
  const { tracks } = await innertubePlayer(videoId);
  return tracks;
}
