---
phase: 10-ai-summaries-auto-save
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/db/schema.ts
  - lib/db/queries.ts
  - app/api/summarize/route.ts
  - lib/summarize.ts
autonomous: true
requirements: [AI-01, AI-02, AI-03, AI-04, AI-05]
user_setup:
  - service: gemini
    why: "AI-powered transcript summarization"
    env_vars:
      - name: GEMINI_API_KEY
        source: "Google AI Studio (https://aistudio.google.com/apikey) -> Create API key"
    dashboard_config: []

must_haves:
  truths:
    - "POST /api/summarize returns bullet and paragraph summaries for a given videoId and transcript text"
    - "Requesting the same videoId twice returns the cached DB result without calling Gemini"
    - "Unauthenticated requests to /api/summarize return 401"
    - "GEMINI_API_KEY is only accessed server-side in the API route"
  artifacts:
    - path: "app/api/summarize/route.ts"
      provides: "Auth-gated summarize endpoint proxying Gemini"
      exports: ["POST"]
    - path: "lib/summarize.ts"
      provides: "Gemini SDK integration, response parser, chunked summarization"
      contains: "parseSummaryResponse"
    - path: "lib/db/schema.ts"
      provides: "summaries table definition"
      contains: "summaries"
    - path: "lib/db/queries.ts"
      provides: "getSummaryByVideoId and saveSummary query helpers"
      contains: "getSummaryByVideoId"
  key_links:
    - from: "app/api/summarize/route.ts"
      to: "lib/summarize.ts"
      via: "generateSummary() call"
      pattern: "generateSummary"
    - from: "app/api/summarize/route.ts"
      to: "lib/db/queries.ts"
      via: "getSummaryByVideoId cache check before Gemini call"
      pattern: "getSummaryByVideoId"
    - from: "lib/summarize.ts"
      to: "@google/genai"
      via: "GoogleGenAI SDK generateContent call"
      pattern: "ai\\.models\\.generateContent"
---

<objective>
Build the server-side summarization backend: summaries DB table with global caching, Gemini SDK integration with response parsing and chunked fallback, and an auth-gated `/api/summarize` route.

Purpose: Provides the backend foundation for AI-powered transcript summaries. The extension (Plan 02) will call this endpoint. The Gemini API key stays server-side, never reaching the extension bundle.

Output: Working `/api/summarize` POST endpoint that accepts `{ videoId, transcriptText }`, checks DB cache, calls Gemini on miss, returns `{ bullets, paragraph }`. New `summaries` table in the database.
</objective>

<execution_context>
@/Users/jakesimpson/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jakesimpson/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-ai-summaries-auto-save/10-RESEARCH.md

@lib/db/schema.ts
@lib/db/queries.ts
@lib/db/index.ts
@app/api/transcript/save/route.ts
@auth.ts
@drizzle.config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add summaries table and query helpers</name>
  <files>lib/db/schema.ts, lib/db/queries.ts</files>
  <action>
Add a `summaries` table to `lib/db/schema.ts` following the existing table patterns (text PK with crypto.randomUUID(), timestamps):

```typescript
export const summaries = pgTable(
  'summaries',
  {
    id: text('id')
      .primaryKey()
      .$defaultFn(() => crypto.randomUUID()),
    videoId: text('videoId').notNull(),
    bullets: text('bullets').notNull(),
    paragraph: text('paragraph').notNull(),
    createdAt: timestamp('createdAt', { mode: 'date' }).defaultNow().notNull(),
  },
  (summary) => [
    uniqueIndex('summary_video_idx').on(summary.videoId),
  ]
);
```

Key details:
- Global cache scope (no userId column) -- summaries are deterministic per video, one summary benefits all users
- `bullets` stores the markdown bullet list as a single text field
- `paragraph` stores the paragraph summary as a single text field
- Unique index on `videoId` for fast cache lookups and deduplication

Add two query helpers to `lib/db/queries.ts`:

```typescript
export async function getSummaryByVideoId(videoId: string) {
  const rows = await db
    .select()
    .from(summaries)
    .where(eq(summaries.videoId, videoId))
    .limit(1);
  return rows[0] ?? null;
}

export async function saveSummary(data: {
  videoId: string;
  bullets: string;
  paragraph: string;
}) {
  return db
    .insert(summaries)
    .values(data)
    .onConflictDoNothing({ target: [summaries.videoId] })
    .returning({ id: summaries.id });
}
```

Import `summaries` from schema in queries.ts. The `onConflictDoNothing` handles race conditions where two users summarize the same video simultaneously.

After modifying the schema, run the DB migration:
```bash
npx drizzle-kit generate
npx drizzle-kit migrate
```

Verify the migration creates the summaries table and the unique index.
  </action>
  <verify>
Run `npx drizzle-kit generate` and `npx drizzle-kit migrate` without errors. Check that a new migration SQL file exists in `drizzle/` that creates the `summaries` table with the `summary_video_idx` unique index. Run `npm run build` to verify TypeScript compiles.
  </verify>
  <done>summaries table exists in the database with a unique index on videoId. getSummaryByVideoId and saveSummary query helpers are available and type-safe.</done>
</task>

<task type="auto">
  <name>Task 2: Create Gemini summarization module and API route</name>
  <files>lib/summarize.ts, app/api/summarize/route.ts</files>
  <action>
Install the Gemini SDK in the web app root (not the extension):
```bash
npm install @google/genai
```

Create `lib/summarize.ts` with:

1. **parseSummaryResponse(text: string)** -- Parse Gemini's structured output into `{ bullets, paragraph }`. Look for `BULLETS:` and `PARAGRAPH:` delimiters (case-insensitive). Fallback: if delimiters are missing, look for lines starting with `- ` for bullets and take remaining text as paragraph. Final fallback: treat entire response as paragraph if nothing else works.

2. **generateSummary(transcriptText: string)** -- Main function that:
   - Creates a GoogleGenAI instance with `process.env.GEMINI_API_KEY`
   - Uses `ai.models.countTokens()` to check if the transcript exceeds 900,000 tokens
   - If under limit: single call to `ai.models.generateContent()` with `gemini-2.5-flash` model and a system instruction that requests both BULLETS and PARAGRAPH formats (see research doc for exact prompt)
   - If over limit: use chunked map-reduce strategy (split transcript into ~500K token chunks by character estimation of 4 chars/token, summarize each chunk, then merge chunk summaries into a final unified summary)
   - Parse the response with `parseSummaryResponse()`
   - Return `{ bullets, paragraph }`
   - On error, throw with a descriptive message (the route handler will catch it)

System instruction for the single-call path:
```
You are a transcript summarizer. Given a YouTube video transcript, produce TWO summaries:

1. BULLETS: 3-7 key takeaway bullet points. Each bullet should be a single concise sentence capturing a distinct main point. Use "- " prefix for each bullet.

2. PARAGRAPH: A cohesive 3-5 sentence paragraph summary covering the main topics and conclusions.

Format your response EXACTLY as:
BULLETS:
- [point 1]
- [point 2]
...

PARAGRAPH:
[paragraph text]
```

Create `app/api/summarize/route.ts`:

- Wrap in `auth()` from `@/auth` (same pattern as `/api/transcript/save/route.ts`)
- Require authentication: return 401 if `!req.auth?.user?.id`
- Parse body: `{ videoId, transcriptText }` -- validate both fields exist
- Check DB cache first: call `getSummaryByVideoId(videoId)`. If found, return cached `{ bullets, paragraph }`
- On cache miss: call `generateSummary(transcriptText)` from `lib/summarize.ts`
- Store result: call `saveSummary({ videoId, bullets, paragraph })`
- Return `{ success: true, data: { bullets, paragraph } }`
- Catch Gemini errors: if the error message includes "429" or "quota", return `{ success: false, error: 'Summary temporarily unavailable' }` with 429 status. For other errors, return generic 500.

Do NOT import `@google/genai` anywhere in the extension directory. It must only be imported in `lib/summarize.ts`.
  </action>
  <verify>
Run `npm run build` to verify TypeScript compiles with no errors. Verify that `@google/genai` is only imported in `lib/summarize.ts` (not in any file under `extension/`). Check that `app/api/summarize/route.ts` exports a POST handler.
  </verify>
  <done>POST /api/summarize is a working auth-gated endpoint that checks DB cache, calls Gemini on miss, stores the result, and returns both bullet and paragraph formats. The Gemini API key is only accessed server-side via process.env.</done>
</task>

</tasks>

<verification>
1. `npm run build` passes with no TypeScript errors
2. New migration file exists in `drizzle/` for the summaries table
3. `app/api/summarize/route.ts` exports POST handler using auth() wrapper
4. `lib/summarize.ts` contains parseSummaryResponse and generateSummary functions
5. `@google/genai` is not imported anywhere under `extension/`
6. `getSummaryByVideoId` and `saveSummary` exist in `lib/db/queries.ts`
</verification>

<success_criteria>
- The summarize API route compiles and is ready to receive requests from the extension
- Summaries are cached globally by videoId in the database
- The Gemini API key never appears in client-side or extension code
- Both bullet and paragraph formats are generated in a single Gemini call
- Chunked summarization handles edge-case long transcripts
</success_criteria>

<output>
After completion, create `.planning/phases/10-ai-summaries-auto-save/10-01-SUMMARY.md`
</output>
