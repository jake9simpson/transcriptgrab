---
phase: 02-database-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/db/schema.ts
  - lib/db/index.ts
  - drizzle.config.ts
  - package.json
autonomous: true
requirements:
  - PERS-02
  - PERS-04
  - PERS-05
  - HIST-01
  - HIST-02
  - HIST-03
  - HIST-04
  - HIST-06
  - HIST-07
  - HIST-08
  - HIST-09
  - HIST-10

user_setup:
  - service: neon-postgres
    why: "Database for storing users, accounts, and transcripts"
    env_vars:
      - name: DATABASE_URL
        source: "Vercel Dashboard > Storage > Create Database > Neon Postgres. After creation, the DATABASE_URL and DATABASE_URL_UNPOOLED env vars are injected automatically. Pull them locally with: npx vercel env pull .env.local"
      - name: DATABASE_URL_UNPOOLED
        source: "Same Neon integration -- injected alongside DATABASE_URL. Used by drizzle-kit for migrations."

must_haves:
  truths:
    - "Schema defines users table with id, name, email, emailVerified, image columns"
    - "Schema defines accounts table with compound primary key on provider+providerAccountId"
    - "Schema defines transcripts table with userId FK, videoId, segments JSONB, and unique constraint on userId+videoId"
    - "Drizzle client exports a db instance connected via Neon HTTP driver"
    - "drizzle.config.ts points to schema file and uses DATABASE_URL_UNPOOLED for migrations"
  artifacts:
    - path: "lib/db/schema.ts"
      provides: "Auth.js adapter tables (users, accounts) and transcripts table"
      contains: "pgTable"
    - path: "lib/db/index.ts"
      provides: "Drizzle client instance for database access"
      contains: "drizzle"
    - path: "drizzle.config.ts"
      provides: "Drizzle Kit configuration for migrations"
      contains: "defineConfig"
  key_links:
    - from: "lib/db/schema.ts"
      to: "lib/types.ts"
      via: "TranscriptSegment type import for JSONB column typing"
      pattern: "TranscriptSegment"
    - from: "lib/db/index.ts"
      to: "lib/db/schema.ts"
      via: "schema import for typed queries"
      pattern: "import.*schema"
    - from: "drizzle.config.ts"
      to: "lib/db/schema.ts"
      via: "schema path reference"
      pattern: "schema.*lib/db/schema"
---

<objective>
Install Drizzle ORM, Neon serverless driver, and Auth.js Drizzle adapter. Define the complete database schema (users, accounts, transcripts tables) and create the Drizzle client and migration config.

Purpose: Establish the schema and tooling foundation so Plan 02 can wire the adapter into Auth.js and run migrations.
Output: Schema file, DB client, drizzle config, and all dependencies installed.
</objective>

<execution_context>
@/Users/jakesimpson/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jakesimpson/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-database-infrastructure/02-RESEARCH.md

@auth.ts
@lib/types.ts
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies and create database schema</name>
  <files>
    package.json
    lib/db/schema.ts
  </files>
  <action>
    Install production deps: `drizzle-orm`, `@neondatabase/serverless`, `@auth/drizzle-adapter`.
    Install dev deps: `drizzle-kit`, `dotenv`.

    Create `lib/db/schema.ts` with three tables:

    1. **users** table (Auth.js adapter format):
       - `id`: text, primary key, default `crypto.randomUUID()`
       - `name`: text, nullable
       - `email`: text, unique
       - `emailVerified`: timestamp with mode "date", nullable
       - `image`: text, nullable

    2. **accounts** table (Auth.js adapter format):
       - `userId`: text, not null, references users.id with onDelete cascade
       - `type`: text, typed as `AdapterAccountType`, not null
       - `provider`: text, not null
       - `providerAccountId`: text, not null
       - `refresh_token`, `access_token`, `id_token`, `session_state`, `scope`, `token_type`: text, nullable
       - `expires_at`: integer, nullable
       - Compound primary key on `(provider, providerAccountId)`

    3. **transcripts** table (application table):
       - `id`: text, primary key, default `crypto.randomUUID()`
       - `userId`: text, not null, references users.id with onDelete cascade
       - `videoId`: text, not null (11-char YouTube ID extracted by `extractVideoId()`)
       - `videoUrl`: text, not null (original URL for display)
       - `videoTitle`: text, not null
       - `thumbnailUrl`: text, nullable
       - `segments`: jsonb typed as `TranscriptSegment[]`, not null (raw timestamped segments for Phase 6 format switching)
       - `savedAt`: timestamp with mode "date", default now(), not null
       - Unique index `transcript_user_video_idx` on `(userId, videoId)`

    Import `TranscriptSegment` from `@/lib/types` for the JSONB column typing.
    Import `AdapterAccountType` from `@auth/core/adapters` for the account type column.

    Use `pgTable` from `drizzle-orm/pg-core` for all table definitions.
    Use `primaryKey` from `drizzle-orm/pg-core` for compound primary key on accounts.
    Use `uniqueIndex` from `drizzle-orm/pg-core` for the transcript unique constraint.

    **Discretionary decision: Store raw segments as JSONB.** Phase 6 (HIST-10) requires format switching without re-fetching. The existing `lib/format.ts` functions (`formatTranscriptText`, `generateSRT`) operate on `TranscriptSegment[]`. Storing raw segments enables client-side format conversion. A typical transcript (~2000 segments at ~80 bytes) is ~160KB, negligible for Neon's 512MB free tier.

    **Discretionary decision: Extract videoId as dedicated column.** YouTube videos have many URL forms (youtube.com/watch?v=, youtu.be/, youtube.com/shorts/) but share one 11-char videoId. Using extracted ID for the unique constraint prevents false-negative duplicate detection. The app already has `extractVideoId()` in `lib/youtube.ts`.
  </action>
  <verify>
    Run `npx tsc --noEmit` -- should pass with no type errors.
    Verify `lib/db/schema.ts` exists and exports `users`, `accounts`, `transcripts`.
  </verify>
  <done>
    All three tables defined with correct columns, types, constraints, and foreign keys. Dependencies installed. TypeScript compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Drizzle client and migration config</name>
  <files>
    lib/db/index.ts
    drizzle.config.ts
  </files>
  <action>
    Create `lib/db/index.ts`:
    - Import `neon` from `@neondatabase/serverless`
    - Import `drizzle` from `drizzle-orm/neon-http`
    - Import `* as schema` from `./schema`
    - Create neon SQL client with `process.env.DATABASE_URL!` (pooled endpoint for application queries)
    - Export `db` as `drizzle(sql, { schema })`

    Create `drizzle.config.ts` at project root:
    - Import `dotenv/config` at top (loads .env.local for local CLI usage)
    - Import `defineConfig` from `drizzle-kit`
    - Export default config with:
      - `schema`: `"./lib/db/schema.ts"`
      - `out`: `"./drizzle"` (migration output directory)
      - `dialect`: `"postgresql"`
      - `dbCredentials.url`: `process.env.DATABASE_URL_UNPOOLED!` (direct connection for DDL migrations -- PgBouncer pooled connections break DDL statements)

    **Why two different DATABASE_URL values:**
    - Application (`lib/db/index.ts`) uses `DATABASE_URL` (pooled via Neon's PgBouncer) -- optimal for serverless function queries
    - Migrations (`drizzle.config.ts`) uses `DATABASE_URL_UNPOOLED` (direct) -- DDL statements need direct connections, not pooled

    Add `drizzle` to `.gitignore` if not already present (migration files should be committed, but the drizzle metadata directory is auto-managed). Actually, migrations SHOULD be committed for production reproducibility. Do NOT add drizzle to gitignore.
  </action>
  <verify>
    Run `npx tsc --noEmit` -- should pass with no type errors.
    Verify `lib/db/index.ts` exports `db`.
    Verify `drizzle.config.ts` exists at project root and references the schema path.
  </verify>
  <done>
    Drizzle client initialized with Neon HTTP driver. Migration config points to schema and uses unpooled connection for DDL safety. TypeScript compiles cleanly.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` succeeds (Next.js build with new schema and client files)
2. `npx tsc --noEmit` passes with no type errors
3. `lib/db/schema.ts` exports `users`, `accounts`, `transcripts` table definitions
4. `lib/db/index.ts` exports `db` Drizzle client instance
5. `drizzle.config.ts` exists at project root with correct schema path and dialect
6. All new dependencies appear in `package.json`
</verification>

<success_criteria>
Schema and tooling are ready. The schema defines Auth.js-compatible users and accounts tables plus an application transcripts table with JSONB segments, proper foreign keys, and a unique constraint for duplicate detection. Drizzle client and migration config are wired to Neon endpoints. TypeScript compiles and Next.js builds.
</success_criteria>

<output>
After completion, create `.planning/phases/02-database-infrastructure/02-01-SUMMARY.md`
</output>
