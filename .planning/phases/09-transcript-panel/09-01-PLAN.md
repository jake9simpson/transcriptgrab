---
phase: 09-transcript-panel
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - extension/utils/types.ts
  - extension/utils/format.ts
  - extension/utils/messaging.ts
  - extension/entrypoints/background/index.ts
autonomous: true
requirements: [PANEL-02]

must_haves:
  truths:
    - "Background service worker fetches real transcript data from the web app API when content script sends getTranscript message"
    - "Background service worker fetches video metadata (title, author) alongside transcript data"
    - "Extension has its own copy of TranscriptSegment, VideoMetadata, and formatting utilities that match the web app"
    - "Messaging protocol carries structured transcript segments and metadata, not placeholder strings"
  artifacts:
    - path: "extension/utils/types.ts"
      provides: "TranscriptSegment, VideoMetadata, TranscriptResponse types for extension"
      contains: "TranscriptSegment"
    - path: "extension/utils/format.ts"
      provides: "formatTranscriptText, formatTimestamp, decodeHtmlEntities ported from web app"
      exports: ["formatTranscriptText", "formatTimestamp", "decodeHtmlEntities"]
    - path: "extension/utils/messaging.ts"
      provides: "Updated ProtocolMap with TranscriptResponse carrying segments + metadata"
      contains: "TranscriptResponse"
    - path: "extension/entrypoints/background/index.ts"
      provides: "Real getTranscript handler calling /api/transcript and /api/metadata"
      contains: "api/transcript"
  key_links:
    - from: "extension/entrypoints/background/index.ts"
      to: "web app /api/transcript"
      via: "fetch POST with videoId"
      pattern: "api/transcript"
    - from: "extension/entrypoints/background/index.ts"
      to: "web app /api/metadata"
      via: "fetch GET with url param"
      pattern: "api/metadata"
    - from: "extension/utils/messaging.ts"
      to: "extension/utils/types.ts"
      via: "TranscriptResponse type references TranscriptSegment and VideoMetadata"
      pattern: "TranscriptResponse"
---

<objective>
Wire the extension backend to fetch real transcripts and metadata from the TranscriptGrab web app API.

Purpose: Phase 8 left the getTranscript handler as a placeholder returning a string. Before building the panel UI, the data pipeline must be real -- types ported, format utilities available, messaging protocol updated, and the background service worker calling the actual API endpoints.

Output: Extension types/format utilities, updated messaging protocol, and a working background fetch that returns structured transcript data.
</objective>

<execution_context>
@/Users/jakesimpson/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jakesimpson/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-extension-foundation/08-01-SUMMARY.md
@.planning/phases/08-extension-foundation/08-02-SUMMARY.md
@.planning/phases/09-transcript-panel/09-RESEARCH.md

# Key source files to reference
@extension/utils/messaging.ts
@extension/utils/constants.ts
@extension/entrypoints/background/index.ts
@extension/entrypoints/background/auth.ts
@lib/types.ts
@lib/format.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Port types and format utilities, update messaging protocol</name>
  <files>extension/utils/types.ts, extension/utils/format.ts, extension/utils/messaging.ts</files>
  <action>
Create `extension/utils/types.ts` with a subset of the web app's `lib/types.ts`:
- `TranscriptSegment` (text, start, duration) -- exact copy
- `VideoMetadata` with only `title` and `author` fields (authorUrl and thumbnailUrl not needed in the extension panel)
- `TranscriptResponse` interface: `{ success: boolean; transcript?: { segments: TranscriptSegment[]; videoId: string }; metadata?: VideoMetadata; error?: string }`

Create `extension/utils/format.ts` by porting from the web app's `lib/format.ts`:
- `decodeHtmlEntities(text: string): string` -- exact copy of the function
- `formatTimestamp(seconds: number): string` -- exact copy
- `formatTranscriptText(segments: TranscriptSegment[], showTimestamps: boolean): string` -- exact copy
- Import `TranscriptSegment` from `./types`
- Do NOT port `generateSRT` or `formatSrtTimestamp` -- not needed in the extension

Update `extension/utils/messaging.ts`:
- Import `TranscriptResponse` from `./types`
- Change the `getTranscript` return type in ProtocolMap from `{ success: boolean; message?: string }` to `TranscriptResponse`
- Keep `checkAuth` unchanged: `() => { isSignedIn: boolean }`
  </action>
  <verify>
Run `cd /Users/jakesimpson/Projects/transcriptgrab/extension && npx tsc --noEmit` to confirm no type errors. Verify `extension/utils/types.ts`, `extension/utils/format.ts`, and `extension/utils/messaging.ts` all exist and contain the expected exports.
  </verify>
  <done>
Extension has its own type definitions and format utilities. Messaging protocol's getTranscript returns `TranscriptResponse` with segments array and metadata instead of a placeholder string.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire background service worker to real transcript and metadata API</name>
  <files>extension/entrypoints/background/index.ts</files>
  <action>
Replace the placeholder `getTranscript` handler in `extension/entrypoints/background/index.ts` with a real implementation:

1. Import `PROD_URL` and `DEV_URL` from `@/utils/constants`
2. Determine the API base URL: `const apiBase = import.meta.env.DEV ? DEV_URL : PROD_URL`
3. In the `getTranscript` handler, extract `videoId` from `data`
4. Construct the YouTube watch URL: `https://www.youtube.com/watch?v=${videoId}`
5. Fire both API calls in parallel using `Promise.all`:
   - `POST ${apiBase}/api/transcript` with JSON body `{ url: youtubeUrl }` and `Content-Type: application/json` header
   - `GET ${apiBase}/api/metadata?url=${encodeURIComponent(youtubeUrl)}`
6. Parse both JSON responses
7. Check the transcript response: if `success` is false or segments are missing, return `{ success: false, error: transcriptData.error || 'Failed to fetch transcript' }`
8. Build and return the `TranscriptResponse`:
   ```
   {
     success: true,
     transcript: { segments: transcriptData.data.segments, videoId },
     metadata: metadataData.success ? { title: metadataData.data.title, author: metadataData.data.author } : undefined,
   }
   ```
9. Wrap everything in try/catch. On network error, return `{ success: false, error: 'Network error fetching transcript' }`
10. Handle metadata failure gracefully: if metadata fetch fails, still return the transcript with `metadata: undefined`. Metadata is supplementary, not required.

Keep the existing `checkAuth` handler, cookie listener, and startup auth check unchanged.
  </action>
  <verify>
Run `cd /Users/jakesimpson/Projects/transcriptgrab/extension && npx tsc --noEmit` to confirm no type errors. Run `npx wxt build` to verify the extension builds successfully.
  </verify>
  <done>
Background service worker calls the real web app API when receiving a getTranscript message. Returns structured TranscriptResponse with segments and metadata on success, or error message on failure. Metadata failures do not block transcript delivery.
  </done>
</task>

</tasks>

<verification>
1. `cd /Users/jakesimpson/Projects/transcriptgrab/extension && npx tsc --noEmit` passes with zero errors
2. `cd /Users/jakesimpson/Projects/transcriptgrab/extension && npx wxt build` completes successfully
3. `extension/utils/types.ts` exports TranscriptSegment, VideoMetadata, TranscriptResponse
4. `extension/utils/format.ts` exports formatTranscriptText, formatTimestamp, decodeHtmlEntities
5. `extension/utils/messaging.ts` ProtocolMap getTranscript returns TranscriptResponse (not the old placeholder type)
6. `extension/entrypoints/background/index.ts` contains fetch calls to `/api/transcript` and `/api/metadata`
</verification>

<success_criteria>
- Extension compiles and builds without errors
- getTranscript message handler fetches from real API endpoints
- TranscriptResponse type carries segments array and metadata object
- Format utilities are available for the panel to use in Plan 02
</success_criteria>

<output>
After completion, create `.planning/phases/09-transcript-panel/09-01-SUMMARY.md`
</output>
