---
phase: 03-transcript-persistence
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/db/schema.ts
  - lib/db/queries.ts
  - lib/youtube.ts
  - lib/types.ts
  - app/api/transcript/route.ts
  - app/api/transcript/save/route.ts
autonomous: true
requirements:
  - PERS-01
  - PERS-02
  - PERS-05

must_haves:
  truths:
    - "POST /api/transcript/save accepts transcript data and inserts into database for authenticated users"
    - "Duplicate transcript (same userId+videoId) is detected atomically and skipped without error"
    - "Unauthenticated requests to save endpoint return 401 without inserting"
    - "Transcript API response includes videoId and videoDuration for client consumption"
    - "videoDuration column exists in transcripts table (nullable integer)"
  artifacts:
    - path: "app/api/transcript/save/route.ts"
      provides: "Save API endpoint with auth check and duplicate detection"
      exports: ["POST"]
    - path: "lib/db/queries.ts"
      provides: "saveTranscript query with onConflictDoNothing + returning"
      exports: ["saveTranscript"]
    - path: "lib/db/schema.ts"
      provides: "transcripts table with videoDuration column"
      contains: "videoDuration"
    - path: "lib/types.ts"
      provides: "Updated TranscriptResult with videoDuration field"
      contains: "videoDuration"
  key_links:
    - from: "app/api/transcript/save/route.ts"
      to: "lib/db/queries.ts"
      via: "saveTranscript() import"
      pattern: "import.*saveTranscript.*from.*lib/db/queries"
    - from: "app/api/transcript/save/route.ts"
      to: "auth.ts"
      via: "auth() wrapper for session check"
      pattern: "auth\\(async function"
    - from: "lib/db/queries.ts"
      to: "lib/db/schema.ts"
      via: "transcripts table reference"
      pattern: "import.*transcripts.*from.*schema"
---

<objective>
Build the backend persistence layer: schema migration for videoDuration, database save query with atomic duplicate detection, save API endpoint with auth gating, and updated transcript API response to include videoId and duration.

Purpose: Establishes the server-side plumbing that the client-side auto-save (Plan 02) will call. Without this, there is no endpoint to persist transcripts.

Output: Save API at `/api/transcript/save`, query helper in `lib/db/queries.ts`, updated schema with `videoDuration`, transcript API returns `videoId` + `videoDuration`.
</objective>

<execution_context>
@/Users/jakesimpson/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jakesimpson/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-transcript-persistence/03-RESEARCH.md

@lib/db/schema.ts
@lib/db/index.ts
@lib/youtube.ts
@lib/types.ts
@app/api/transcript/route.ts
@auth.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Schema migration + save query + types update</name>
  <files>
    lib/db/schema.ts
    lib/db/queries.ts
    lib/types.ts
    lib/youtube.ts
    app/api/transcript/route.ts
  </files>
  <action>
1. **Add videoDuration to schema** (`lib/db/schema.ts`):
   - Add `videoDuration: integer("videoDuration")` to the transcripts table (nullable, no `.notNull()`).
   - Place it after `thumbnailUrl` and before `segments`.

2. **Run schema migration**:
   ```bash
   npx drizzle-kit generate
   npx drizzle-kit migrate
   ```
   This generates a SQL migration adding the column and applies it to the Neon database. Use the `DATABASE_URL` from `.env.local` (the unpooled endpoint for migrations, per Phase 02 convention).

3. **Create `lib/db/queries.ts`**:
   ```typescript
   import { db } from "@/lib/db";
   import { transcripts } from "@/lib/db/schema";
   import type { TranscriptSegment } from "@/lib/types";

   export async function saveTranscript(data: {
     userId: string;
     videoId: string;
     videoUrl: string;
     videoTitle: string;
     thumbnailUrl: string | null;
     videoDuration: number | null;
     segments: TranscriptSegment[];
   }) {
     const rows = await db
       .insert(transcripts)
       .values(data)
       .onConflictDoNothing({
         target: [transcripts.userId, transcripts.videoId],
       })
       .returning({ id: transcripts.id });

     return { inserted: rows.length > 0, id: rows[0]?.id ?? null };
   }
   ```
   Uses `onConflictDoNothing` on the existing `(userId, videoId)` unique index. RETURNING returns empty array when conflict fires (duplicate detected). This is the locked user decision: skip saving entirely on duplicates, preserve original save date.

4. **Update `TranscriptResult` type** (`lib/types.ts`):
   - Add `videoDuration?: number | null` to the `TranscriptResult` interface.
   - This field is optional because Supadata fallback may not provide it.

5. **Extract duration from InnerTube** (`lib/youtube.ts`):
   - In `innertubePlayer()`, after parsing `captionRenderer`, extract: `const lengthSeconds = data?.videoDetails?.lengthSeconds ? parseInt(data.videoDetails.lengthSeconds, 10) : null;`
   - Update the return type of `innertubePlayer()` to include `lengthSeconds: number | null`.
   - Return `{ tracks, rawTracks, lengthSeconds }`.
   - In `fetchTranscript()`, after the InnerTube success path, include `videoDuration: lengthSeconds` in the returned `TranscriptResult`.
   - For the Supadata fallback path, set `videoDuration: null` (Supadata doesn't provide duration).

6. **Update transcript API response** (`app/api/transcript/route.ts`):
   - The existing route already returns the full `TranscriptResult` via `{ success: true, data }`. Since `fetchTranscript()` now returns `videoDuration` as part of the result, no changes needed to the route handler itself. But verify that `TranscriptResult` flows through correctly to the JSON response, including the new `videoDuration` field.
   - Ensure the response also includes `videoId` (already present in `TranscriptResult`).
  </action>
  <verify>
    - `npm run build` completes without TypeScript errors.
    - Schema migration generated and applied: check `drizzle/` directory for new migration SQL containing `videoDuration`.
    - `lib/db/queries.ts` exports `saveTranscript`.
    - `lib/types.ts` contains `videoDuration` in `TranscriptResult`.
    - `lib/youtube.ts` returns `videoDuration` from `fetchTranscript()`.
  </verify>
  <done>
    - transcripts table has nullable `videoDuration` integer column in Neon.
    - `saveTranscript()` function handles insert-or-skip with atomic duplicate detection.
    - `TranscriptResult` includes `videoDuration` field.
    - InnerTube path extracts and returns `lengthSeconds` as `videoDuration`.
    - Supadata path returns `videoDuration: null`.
    - Build passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Save API endpoint with auth gating</name>
  <files>
    app/api/transcript/save/route.ts
  </files>
  <action>
Create `app/api/transcript/save/route.ts`:

```typescript
import { auth } from "@/auth";
import { NextResponse } from "next/server";
import { saveTranscript } from "@/lib/db/queries";

export const POST = auth(async function POST(req) {
  if (!req.auth?.user?.id) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  try {
    const body = await req.json();

    // Validate required fields
    const { videoId, videoUrl, videoTitle, thumbnailUrl, videoDuration, segments } = body;
    if (!videoId || !videoUrl || !videoTitle || !Array.isArray(segments) || segments.length === 0) {
      return NextResponse.json({ error: "Missing required fields" }, { status: 400 });
    }

    const result = await saveTranscript({
      userId: req.auth.user.id,
      videoId,
      videoUrl,
      videoTitle,
      thumbnailUrl: thumbnailUrl ?? null,
      videoDuration: typeof videoDuration === "number" ? videoDuration : null,
      segments,
    });

    return NextResponse.json(result);
  } catch {
    return NextResponse.json({ error: "Failed to save transcript" }, { status: 500 });
  }
});
```

Key implementation details:
- Uses `auth()` wrapper pattern from Auth.js v5 (same pattern as verified in Research doc and used in Phase 01).
- Checks `req.auth?.user?.id` for session presence. Returns 401 if unauthenticated.
- Validates required body fields before calling `saveTranscript()`.
- Returns `{ inserted: boolean, id: string | null }` on success.
- Catches and returns 500 on unexpected errors (save failures are ultimately handled silently on the client, but the endpoint should still return proper HTTP status).
- No retry logic (per discretionary decision: no retry on save failure).
  </action>
  <verify>
    - `npm run build` completes without errors.
    - File exists at `app/api/transcript/save/route.ts` and exports `POST`.
    - TypeScript compiles: the `auth()` wrapper signature matches the Auth.js v5 pattern.
  </verify>
  <done>
    - `POST /api/transcript/save` accepts transcript data and saves for authenticated users.
    - Unauthenticated requests return 401.
    - Missing required fields return 400.
    - Duplicate transcripts return `{ inserted: false, id: null }` (no error, conflict silently skipped).
    - New transcripts return `{ inserted: true, id: "<uuid>" }`.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` passes with zero TypeScript errors.
2. Migration SQL in `drizzle/` directory adds `videoDuration` column.
3. `lib/db/queries.ts` exists and exports `saveTranscript`.
4. `app/api/transcript/save/route.ts` exists and exports `POST`.
5. `TranscriptResult` type includes `videoDuration`.
6. `fetchTranscript()` returns `videoDuration` in its result object.
</verification>

<success_criteria>
- Backend persistence layer is complete and ready for client-side integration.
- Save endpoint authenticates, validates, inserts (or skips duplicates), and responds.
- Transcript API response carries all data the client needs to construct a save payload (videoId, videoDuration, segments, plus metadata from the existing metadata API).
- Schema migration applied to production database.
- Build passes.
</success_criteria>

<output>
After completion, create `.planning/phases/03-transcript-persistence/03-01-SUMMARY.md`
</output>
