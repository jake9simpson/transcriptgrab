---
phase: 02-database-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - auth.ts
autonomous: false
requirements:
  - PERS-01
  - PERS-03
  - HIST-05

user_setup: []

must_haves:
  truths:
    - "Auth.js uses DrizzleAdapter with custom users and accounts tables from lib/db/schema.ts"
    - "JWT session strategy is preserved (no database sessions)"
    - "User ID from database is available in session via JWT callbacks"
    - "New user signing in with Google creates user and account rows in database"
    - "Existing JWT sessions continue to work after adapter is added (re-auth creates DB records)"
  artifacts:
    - path: "auth.ts"
      provides: "Auth.js config with DrizzleAdapter wired to Neon database"
      contains: "DrizzleAdapter"
  key_links:
    - from: "auth.ts"
      to: "lib/db/index.ts"
      via: "db import for adapter"
      pattern: "import.*db.*from.*lib/db"
    - from: "auth.ts"
      to: "lib/db/schema.ts"
      via: "users and accounts table imports for adapter config"
      pattern: "import.*users.*accounts.*from.*lib/db/schema"
---

<objective>
Wire the Drizzle adapter into the existing Auth.js configuration so that user sign-ins create database records. Then generate the initial migration and provide a checkpoint for the user to provision the Neon database and run migrations.

Purpose: Connect Auth.js to the database so user and account records persist, enabling foreign keys for transcript storage in Phase 3.
Output: Updated auth.ts with DrizzleAdapter, generated migration files, verified end-to-end.
</objective>

<execution_context>
@/Users/jakesimpson/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jakesimpson/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-database-infrastructure/02-RESEARCH.md
@.planning/phases/02-database-infrastructure/02-01-SUMMARY.md

@auth.ts
@lib/db/schema.ts
@lib/db/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire DrizzleAdapter into Auth.js config and generate migration</name>
  <files>
    auth.ts
  </files>
  <action>
    Update `auth.ts` to add the Drizzle adapter:

    1. Add imports:
       - `DrizzleAdapter` from `@auth/drizzle-adapter`
       - `db` from `@/lib/db`
       - `users, accounts` from `@/lib/db/schema`

    2. Add `adapter` property to NextAuth config:
       ```
       adapter: DrizzleAdapter(db, {
         usersTable: users,
         accountsTable: accounts,
       }),
       ```

    3. **Keep everything else identical:**
       - `providers: [Google]` -- unchanged
       - `session.strategy: "jwt"` with 30-day maxAge -- unchanged (locked decision: JWT sessions, no DB session storage)
       - `callbacks.jwt` -- unchanged (passes user.id to token)
       - `callbacks.session` -- unchanged (passes token.id to session)

    **Why JWT strategy must be explicitly set with adapter:** When an adapter is configured, Auth.js defaults to database sessions. The explicit `strategy: "jwt"` overrides this, keeping sessions in the cookie per locked decision. The adapter only handles user/account creation, not session storage.

    **Existing user impact:** Users who signed in before the adapter was added have JWT tokens with internally-generated IDs. After deploying the adapter, these tokens reference IDs that don't exist in the database. When these users' JWTs expire (30 days) or they sign out, their next sign-in will create proper database records. This is acceptable for an early-stage app. No migration of existing sessions is needed.

    4. Generate the initial migration:
       Run `npx drizzle-kit generate` to create the SQL migration file in `./drizzle/`.
       This creates the `user`, `account`, and `transcript` tables with all columns, constraints, indexes, and foreign keys.

    5. Verify the generated SQL looks correct (should contain CREATE TABLE for user, account, transcript, plus the unique index and foreign keys).

    The migration will be applied by the user after provisioning the Neon database (see checkpoint task below).
  </action>
  <verify>
    Run `npx tsc --noEmit` -- should pass.
    Run `npm run build` -- should succeed.
    Verify `auth.ts` imports DrizzleAdapter, db, users, accounts.
    Verify `auth.ts` still has `strategy: "jwt"` in session config.
    Verify migration SQL file exists in `./drizzle/` directory.
  </verify>
  <done>
    Auth.js config uses DrizzleAdapter with custom tables from schema. JWT strategy preserved. Initial migration generated and ready to apply. Build passes.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Provision Neon database and run migration</name>
  <files>N/A (human action)</files>
  <action>
    Human provisions Neon Postgres via Vercel Dashboard, pulls env vars, runs migration, and verifies sign-in creates database records.

    **What was built:**
    Complete database infrastructure: Drizzle ORM schema (users, accounts, transcripts), Neon HTTP client, Auth.js DrizzleAdapter integration, and generated SQL migration. The schema stores raw transcript segments as JSONB for Phase 6 format switching, uses extracted videoId (not full URL) for duplicate detection, and only creates users+accounts tables (no session/verificationToken tables since we use JWT sessions).

    **How to verify:**

    **Step 1: Provision Neon Postgres via Vercel**
    1. Go to your Vercel Dashboard for the transcriptgrab project
    2. Navigate to Storage tab > Create Database > Neon Postgres
    3. This automatically injects `DATABASE_URL` and `DATABASE_URL_UNPOOLED` env vars

    **Step 2: Pull env vars locally**
    ```bash
    npx vercel env pull .env.local
    ```
    Verify `.env.local` now contains `DATABASE_URL` and `DATABASE_URL_UNPOOLED` values.

    **Step 3: Run the migration**
    ```bash
    npx drizzle-kit migrate
    ```
    Should output "Migration completed" with no errors. This creates the user, account, and transcript tables in your Neon database.

    **Step 4: Test the auth flow**
    ```bash
    npm run dev
    ```
    1. Open http://localhost:3000
    2. Click "Sign in with Google" and complete the OAuth flow
    3. After sign-in, you should see your avatar/name in the header
    4. Check the Neon console (or run `npx drizzle-kit studio`) -- there should be a row in the `user` table and a row in the `account` table for your Google sign-in

    **Step 5: Verify on Vercel (production)**
    ```bash
    npx vercel --prod --yes
    ```
    After deploy, test sign-in on the production URL. The database is already provisioned from Step 1.

    **Expected state after verification:**
    - Three tables exist in Neon: `user`, `account`, `transcript`
    - Signing in creates user + account records
    - JWT session still works (no database session hits)
    - Unauthenticated users can still use the transcript tool without any changes
  </action>
  <verify>User confirms sign-in creates database records and transcript tool still works for unauthenticated users.</verify>
  <done>Neon database provisioned, migration applied, sign-in creates user + account rows, JWT sessions preserved, unauthenticated access unaffected.</done>
</task>

</tasks>

<verification>
1. `npm run build` succeeds
2. `auth.ts` contains DrizzleAdapter with usersTable and accountsTable
3. `auth.ts` still has `session.strategy: "jwt"` (locked decision)
4. Migration SQL file exists in `./drizzle/` with CREATE TABLE statements
5. After user provisions database and runs migration: sign-in creates user + account rows
6. Unauthenticated access to transcript tool still works (no regression)
</verification>

<success_criteria>
Auth.js adapter is wired to Neon database via Drizzle. Signing in with Google creates user and account records in the database. JWT session strategy is preserved. Migration has been applied to production. The transcripts table exists and is ready for Phase 3 to write to it.
</success_criteria>

<output>
After completion, create `.planning/phases/02-database-infrastructure/02-02-SUMMARY.md`
</output>
